# ref설명

```
const startTime = useRef();
const endTime = useRef();
```

- current 속성은 useRef Hook에서 반환되는 ref 객체의 속성
- useRef Hook은 변경 가능한 ref 객체를 반환한다.
- 이 객체는 .current 프로퍼티를 갖고 있고, 이 프로퍼티는 초기화 할 때의 인자값(해당 경우에는 new Date())을 가진다.
- 이 .current 속성은 ref의 현재 값을 가리키며, 이 값은 변경 가능하다.
- 이 속성을 통해 ref가 가리키는 값에 접근하거나 변경 가능. 이는 변수의 값을 기억하는데 사용되거나, DOM 엘리먼트에 직접 접근하는 등 여러 용도로 사용한다.
- 예를 들어, startTime.current = new Date();는 startTime ref의 현재 값을 현재 시간으로 설정한다.
- 이 값을 나중에 다른 시간과 비교하거나, 특정 작업이 얼마나 걸렸는지를 측정하는 데 사용 가능하다.
- 이렇게 사용하는 이유 중 하나는 ref 값이 변경되어도 컴포넌트가 리렌더링되지 않기 때문.
- 이것은 변수를 기억하고 싶지만, 그 변경에 따른 리렌더링은 원하지 않는 경우 유용하다.

# timeout 설명

```javascript
const timeout = () => {
  const id = setTimeout(() => {
    setGameState((prevState) => ({
      ...prevState,
      state: "now",
      message: "지금 클릭하세요!",
    }));
    startTime.current = new Date();
  }, Math.floor(Math.random() * 1000 + 3000));
  setTimeoutId(id);
};
```

- prevState는 현재 state의 이전 상태
- { ...prevState, state: "now", message: "지금 클릭하세요!" }는 새로운 state 객체이다.
- 이 객체는 이전 state에 기반을 두고 있으며, state와 message 필드만 수정하고 있음
- ...prevState는 JavaScript의 스프레드 연산자를 사용한 것으로, 이전 state 객체의 모든 필드를 새로운 객체에 복사한다.
- 그런 다음, state: "now", message: "지금 클릭하세요!" 부분으로 state와 message 필드를 새로운 값으로 업데이트한다.
- 이렇게 하면, state 객체의 다른 필드는 그대로 유지되고, state와 message 필드만 새로운 값으로 업데이트된다.
- 이것은 React에서 state를 업데이트할 때 불변성을 유지하는 것이 중요한 이유와 관련이 있음 즉, state를 직접 수정하는 것이 아니라, 항상 새로운 state 객체를 생성해야 한다.
- 비동기적인 state 업데이트가 필요한 경우, 이전 state를 기반으로 새로운 state를 계산해야 할 때 이런 패턴을 사용한다.
- 여기서 비동기적이라는 것은, state 업데이트가 즉시 발생하지 않고, 어느 시점에 발생할지 확실하지 않다는 의미 이는 React의 state 업데이트 메커니즘에 따른 것이다.

# startime이랑 endtime 변수로 선언하면 안되는 이유

- 그냥 변수로 선언하여 사용하는 것은 피해야 하는데, 그 이유는 React 컴포넌트가 렌더링 될 때마다 변수는 새로 생성되기 때문이다. <br>
  따라서, 시작 시간과 종료 시간을 기록하려면 변수가 렌더링 사이에서 값을 유지하도록 해야 하는데, 이를 위해 useRef Hook을 사용하는 것이다.

- 예를 들어, 사용자가 버튼을 클릭하여 반응 시간을 측정하려고 한다.<br>
  클릭을 하면 시작 시간이 기록되고, 다시 클릭하면 종료 시간이 기록된다.<br>
  그리고, 두 시간의 차이가 사용자의 반응 시간이다.

- 이를 위해 단순한 변수를 사용하려고 한다면, 시작 시간을 기록할 때 해당 시간을 변수에 저장하고, 종료 시간을 기록할 때 해당 시간을 또 다른 변수에 저장할 것이다.<br>
  그런 다음 두 변수의 차이를 계산하여 반응 시간을 얻을 것이다.<br>
  그러나, 이 방법의 문제점은 React 컴포넌트가 다시 렌더링 될 때마다 이 변수들이 초기화되기 때문에 시작 시간이 사라져 버린다.<br>
  즉, 종료 시간을 기록할 때 시작 시간이 더 이상 없어, 반응 시간을 계산할 수 없게 된다.

- 반면에 useRef Hook을 사용하면, useRef가 반환하는 ref 객체의 .current 속성을 통해 값을 유지할 수 있다.<br>
  이 .current 속성은 컴포넌트가 다시 렌더링 될 때도 값이 유지되기 때문에, 시작 시간과 종료 시간을 기록하고, 이 두 시간의 차이를 계산하는 것이 가능해진다.

- 따라서 startTime과 endTime을 기록하고 유지하기 위해 useRef Hook을 사용하는 것이며, 이를 통해 반응 시간을 정확하게 측정할 수 있다.

# useState를 사용하면 안되는 이유

- useState를 사용하여 startTime과 endTime를 관리할 수 있지만, useState를 사용할 때마다 상태가 변경되면 컴포넌트가 다시 렌더링되는 사실을 명심해야 한다.

- 이 경우, startTime과 endTime는 사용자가 버튼을 클릭할 때마다 업데이트되므로, 이 값들이 변경될 때마다 컴포넌트가 다시 렌더링되게 된다.<br>
  이렇게 되면 성능에 부정적인 영향을 미칠 수 있으며, 이를 피하려면 useRef를 사용하는 것이 좋다.

- useRef는 useState와는 달리 ref 객체를 변경해도 컴포넌트가 다시 렌더링되지 않는다.<br>
  이것은 startTime과 endTime과 같이 반응 시간 측정에서 필요한 값이지만 그 자체로 렌더링에 관련되지 않는 경우에 특히 유용하다.

- 따라서 useState는 상태가 변경될 때 컴포넌트를 다시 렌더링하려는 경우에 적합하며, useRef는 값을 저장하고 추적하는데 사용되지만 그 자체로는 렌더링을 발생시키지 않아야 하는 경우에 적합하다.
